datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Campaign {
  uri             String    @id
  title           String?  
  description     String?
  creator         User?     @relation(fields: [creatorId], references: [address])
  creatorId       String?    
  nonce           Int
  chainId         Int?      // store the ChainId as defined in wagmi defaultChains
  asset           String?   // store the Asset id as defined in @dao-strategies/core ChainsDetails
  guardian        String?
  oracle          String?
  activationTime    Int?
  CHALLENGE_PERIOD  Int?
  ACTIVATION_PERIOD Int?
  ACTIVE_DURATION   Int?
  stratID         String
  stratParamsStr  String    // For now, Params are stringified as they can have any structure
  rewards         Reward[] 
  lastRunDate     BigInt?
  execDate        BigInt?
  publishDate     BigInt?
  cancelDate      BigInt?
  registered      Boolean?  // Registered campaigns are those live (with a smart contract). 
  running         Boolean?  // running campaigns are currently being run (execution can take a few seconds or minutes)
  executed        Boolean?  // executed campaigns are those whose final rewards have been computed 
  published       Boolean?  // published campaigns are those whose shares has been published in their smart contract
  address         String?   // cannot be @unique since it is null for simulated campaigns - Smart contract address
  isComputing     Boolean   // prevent reentrancy issues (two roots being computed at once)
  roots           CampaignRoot[] 
}

enum CampaignState {
  PendingExecution
  PendingIdentityValidation
  MerkleRootSet
}

model User {
  address         String    @id
  verifiedGithub  String?
  signedGithub    String?
  created         Campaign[]
} 

model Reward {  
  @@id([campaignId, account])
  account         String
  amount          BigInt        
  campaign        Campaign  @relation(fields: [campaignId], references: [uri])
  campaignId      String
}

model CampaignRoot {
  @@id([campaignId, root])
  campaign        Campaign  @relation(fields: [campaignId], references: [uri])
  campaignId      String
  root            String
  date            BigInt
  balances        BalanceLeaf[]   // Leafs are stored on a table to be efficiently read
}

model BalanceLeaf {
  @@id([campaignId, rootId, address])
  root            CampaignRoot  @relation(fields: [campaignId, rootId], references: [campaignId, root])
  campaignId      String
  rootId          String
  address         String
  balance         String
  proof           String[]      // Store the proofs so that they don't have to be recomputed eveytime they are needed
}

model AssetPrice {
  @@id([chainId, address])
  chainId         Int
  address         String
  price           Float
  lastUpdated     BigInt
}